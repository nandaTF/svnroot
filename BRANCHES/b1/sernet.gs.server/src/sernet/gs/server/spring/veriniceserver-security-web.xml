<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
	http://www.springframework.org/schema/aop spring-aop-3.2.xsd 
	http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.1.xsd">

	<!-- 
     Security configuration which provides digest authentication: for the rich client
     and ordinary web form based authentication for the web client. 
     Transmits passwords in clear text when not using HTTPS.
    -->
	
	<bean id="authenticationManager" class="org.springframework.security.authentication.ProviderManager">
	<!-- <security:authentication-manager alias="authenticationManager">	 -->
		<property name="providers">
		<!-- <security:authentication-provider user-service-ref="veriniceAuthenticationProvider"/> -->
			<list>
				<ref local="veriniceAuthenticationProvider"/>
				<ref local="anonymousAuthenticationProvider"/>
		
			</list>
		<!-- <security:authentication-provider user-service-ref="anonymousAuthenticationProvider" /> -->
		</property>
		<!-- <security:authentication-provider>
			<security:password-encoder hash="md5"/>
			<security:user-service>
				<security:user name="admin" password="$1$/QPB78tZ$kqU3m0xuoZDVFsgzn7U5n0"/>
			</security:user-service>
		</security:authentication-provider>
	</security:authentication-manager> -->
	</bean>
	
    <bean id="veriniceAuthenticationProvider" class="sernet.gs.server.security.AuthenticationProvider">
        <!--  <security:custom-authentication-provider /> -->
        <property name="userDetailsService" ref="userDetailsService" />
        <property name="realmName" value="${veriniceserver.realm}" />
    </bean>
    
    <bean id="userDetailsService" class="sernet.gs.server.security.DbUserDetailsService">
        <property name="entityDao" ref="entityDao" />
        <property name="adminuser">
            <value>${admin.username}</value>
        </property>
        <property name="adminpass">
            <value>${admin.password}</value>
        </property>
    </bean>


    <bean id="authService" class="sernet.gs.server.security.DigestAuthenticationService">
        <property name="entryPoint" ref="digestProcessingFilterEntryPoint" />
        <property name="adminUsername" value="${admin.username}" />
        <!-- method-access now secured by annotations within the class (spring3) -->
        <!-- <security:intercept-methods> -->
             <!-- must be logged in to access roles: -->
            <!-- <security:protect method="sernet.gs.server.security.DigestAuthenticationService.getRoles" access="ROLE_USER,ROLE_WEB" /> -->
             <!-- must be logged in as admin to change passwords: -->
            <!-- <security:protect method="sernet.gs.server.security.DigestAuthenticationService.hashPassword" access="ROLE_USER,ROLE_WEB" /> -->
        <!-- </security:intercept-methods> -->
    </bean>


    <!-- The filter chain that all HTTP requests go through: -->
    
	<bean id="springSecurityFilterChain" class="org.springframework.security.web.FilterChainProxy">
        <constructor-arg>
        	<list>
				<security:filter-chain pattern="/auth/**" filters="httpSessionContextIntegrationFilter,anonymousAuthFilter,authenticationProcessingFilter,logoutFilter,timeoutFilter,exceptionTranslationFilterWeb,securityInterceptorFilter" />
            	<security:filter-chain pattern="/edit/**" filters="httpSessionContextIntegrationFilter,authenticationProcessingFilter,exceptionTranslationFilterWeb,securityInterceptorFilter" />
            	<security:filter-chain pattern="/todo/**" filters="httpSessionContextIntegrationFilter,authenticationProcessingFilter,exceptionTranslationFilterWeb,securityInterceptorFilter" />       
            	<security:filter-chain pattern="/sync/**" filters="httpSessionContextIntegrationFilter,digestProcessingFilter,exceptionTranslationFilter,securityInterceptorFilter" /> 
				<security:filter-chain pattern="/service/**" filters="httpSessionContextIntegrationFilter,digestProcessingFilter,exceptionTranslationFilter,securityInterceptorFilter" />        		
        	</list>
        </constructor-arg>
        <!-- <property name="matcher">
            <bean class="org.springframework.security.web.util.AntUrlPathMatcher"/>
        </property>
        <property name="filterChainMap"> 
        	<map>
        		<entry key="/auth/**">
        			<list>
        				<ref local="httpSessionContextIntegrationFilter"/>
        				<ref local="anonymousAuthFilter"/>
        				<ref local="authenticationProcessingFilter"/>
        				<ref local="logoutFilter"/>
        				<ref local="timeoutFilter"/>
        				<ref local="exceptionTranslationFilterWeb"/>
        				<ref local="securityInterceptorFilter"/>
        			</list>
        		</entry>
        		<entry key="/edit/**">
        			<list>
        				<ref local="httpSessionContextIntegrationFilter"/>
        				<ref local="authenticationProcessingFilter"/>
        				<ref local="exceptionTranslationFilterWeb"/>
        				<ref local="securityInterceptorFilter"/>
        			</list>
        		</entry>
        		<entry key="/todo/**">
        			<list>
        				<ref local="httpSessionContextIntegrationFilter"/>
        				<ref local="authenticationProcessingFilter"/>
        				<ref local="exceptionTranslationFilterWeb"/>
        				<ref local="securityInterceptorFilter"/>
        			</list>        			
        		</entry>
        		<entry key="/sync/**">
        			<list>
        				<ref local="httpSessionContextIntegrationFilter"/>
        				<ref local="digestProcessingFilter"/>
        				<ref local="exceptionTranslationFilterWeb"/>
        				<ref local="securityInterceptorFilter"/>
        			</list>           		
        		</entry>
        		<entry key="/service/**">
        			<list>
               			<ref local="httpSessionContextIntegrationFilter"/>
	        			<ref local="digestProcessingFilter"/>
   	     				<ref local="exceptionTranslationFilterWeb"/>
   	     				<ref local="securityInterceptorFilter"/>
   	     			</list>  		
        		</entry>
        	</map>
        </property> -->
    </bean>
    <bean id="httpSessionContextIntegrationFilter" class="org.springframework.security.context.HttpSessionContextIntegrationFilter" />
    
    <bean id="anonymousAuthFilter" class="org.springframework.security.web.authentication.AnonymousAuthenticationFilter">
        <property name="key" value="foobar" />
        <property name="userAttribute" value="anonymousUser,ROLE_ANONYMOUS" />
    </bean>

    <bean id="anonymousAuthenticationProvider" class="org.springframework.security.authentication.AnonymousAuthenticationProvider">
        <property name="key" value="foobar" />
    </bean>
    
    <!--  <bean id="authenticationProcessingFilter" class="org.springframework.security.ui.webapp.AuthenticationProcessingFilter"> -->
    <bean id="authenticationProcessingFilter" class="org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter">
        <property name="authenticationManager" ref="authenticationManager" />
        <property name="filterProcessesUrl" value="/auth/j_verinice_security_check" />
        <!-- <property name="defaultTargetUrl" value="/todo/task.jsf" /> Deprecated in Spring3-->
        <!-- <property name="authenticationFailureUrl" value="/auth/login-error.jsf" />Deprecated in Spring3-->
    </bean>
    
    <!-- Using digest authentication: (doesn't work with LDAP) 
    
	 Instead of digest auth, the authentication method can be switched, i.e. to basic auth over SSL with SHA hashes.
	 Please refer to the Spring framework security documentation for instructions on how to do this 
	 (http://static.springsource.org/spring-security/site/suggested.html).
     However, digest auth works just as well over SSL.
     
     Digest authentication however is not supported when using LDAP / AD bind authentication, since LDAP uses a different hashing
     algorithm for passwords so there would be no way to compare the A1 hash against the directory. Basic authentication transmits the password in clear text over HTTP, so make sure to
     use HTTPS when switching to LDAP / AD authentication too!
     
    -->
    
    <bean id="exceptionTranslationFilter" class="org.springframework.security.web.access.ExceptionTranslationFilter">
        <property name="authenticationEntryPoint" ref="digestProcessingFilterEntryPoint" />
    </bean>
    
    <!-- <bean id="digestProcessingFilter" class="org.springframework.security.ui.digestauth.DigestProcessingFilter"> -->
    <bean id="digestProcessingFilter" class="org.springframework.security.web.authentication.www.DigestAuthenticationFilter">
        <property name="userDetailsService" ref="userDetailsService" />
        <property name="authenticationEntryPoint" ref="digestProcessingFilterEntryPoint" />
        <property name="passwordAlreadyEncoded" value="true" />
    </bean>
    
    <!-- <bean id="digestProcessingFilterEntryPoint" class="org.springframework.security.ui.digestauth.DigestProcessingFilterEntryPoint"> -->
    <bean id="digestProcessingFilterEntryPoint" class="org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint">
        <property name="realmName" value="${veriniceserver.realm}" />
        <property name="key" value="${veriniceserver.key}" />
        <property name="nonceValiditySeconds" value="${veriniceserver.nonceValiditySeconds}" />
    </bean>
   
    
    <bean id="exceptionTranslationFilterWeb" class="org.springframework.security.web.access.ExceptionTranslationFilter">
        <property name="authenticationEntryPoint" ref="authenticationEntryPoint" />
        <property name="accessDeniedHandler" ref="accessDeniedHandler" />
    </bean>

    <!-- <bean id="authenticationEntryPoint" class="org.springframework.security.ui.webapp.AuthenticationProcessingFilterEntryPoint">-->
	<!-- <bean id="authenticationEntryPoint"	class="org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint"> -->
	<bean id="authenticationEntryPoint"	class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
        <property name="loginFormUrl" value="/auth/login.jsf" />
        <property name="forceHttps" value="false" />
    </bean>

    <bean id="accessDeniedHandler" class="org.springframework.security.web.access.AccessDeniedHandlerImpl">
        <property name="errorPage" value="/auth/login-error.jsf" />
    </bean>
    

    <bean id="logoutFilter" class="org.springframework.security.web.authentication.logout.LogoutFilter">
        <constructor-arg value="/auth/login.jsf" />
        <constructor-arg>
            <list>
                <bean class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler" />
            </list>
        </constructor-arg>
        <property name="filterProcessesUrl" value="/auth/j_verinice_logout" />
    </bean>
    
    <bean id="timeoutFilter" class="org.springframework.security.web.authentication.logout.LogoutFilter">
        <constructor-arg value="/auth/login-timeout.jsf" />
        <constructor-arg>
            <list>
                <bean class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler" />
            </list>
        </constructor-arg>
        <property name="filterProcessesUrl" value="/auth/j_verinice_timeout" />
    </bean>

    <!-- Protect HTTP access to these paths: -->
	<bean id="securityInterceptorFilter" class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor">
		<property name="authenticationManager" ref="authenticationManager" />
		<property name="accessDecisionManager" ref="accessDecisionManager" />
		<!-- <property name="objectDefinitionSource"> --> 
		<property name="securityMetadataSource">
			<security:filter-security-metadata-source>
                <security:intercept-url pattern="/auth/j_verinice_security_check" access="ROLE_ANONYMOUS"/>
                <security:intercept-url pattern="/auth/login.jsf" access="ROLE_ANONYMOUS"/>
                <security:intercept-url pattern="/edit/**" access="ROLE_WEB" />
                <security:intercept-url pattern="/todo/**" access="ROLE_WEB" />
                <security:intercept-url pattern="/service/**" access="ROLE_USER" />
				<security:intercept-url pattern="/sync/**" access="ROLE_USER" />
			</security:filter-security-metadata-source>
		</property>
	</bean>
	
	<!-- <security:http use-expressions="true">
                <security:intercept-url pattern="/auth/j_verinice_security_check" access=hasRole('ROLE_ANONYMOUS')/>
                <security:intercept-url pattern="/auth/login.jsf" access=hasRole('ROLE_ANONYMOUS')/>
                <security:intercept-url pattern="/edit/**" access=hasRole('ROLE_WEB') />
                <security:intercept-url pattern="/todo/**" access=hasRole('ROLE_WEB') />
                <security:intercept-url pattern="/service/**" access=hasRole('ROLE_USER') />
				<security:intercept-url pattern="/sync/**" access=hasRole('ROLE_USER') />		
	</security:http> -->

	<!-- <bean id="roleVoter" class="org.springframework.security.access.vote.RoleVoter">
    	<property name="rolePrefix" value="ROLE_"/>
	</bean> -->

	<bean id="accessDecisionManager" class="org.springframework.security.access.vote.AffirmativeBased">
		<property name="allowIfAllAbstainDecisions" value="false" />
		<property name="decisionVoters">
			<list>
				<bean class="org.springframework.security.access.vote.RoleVoter" />
			</list>
		</property>
	</bean>
	<!-- <bean id="accessDecisionManager" class="org.springframework.security.access.vote.AffirmativeBased">
    <constructor-arg >
        <list>
            <ref bean="roleVoter"/>
        </list>
    </constructor-arg>
	</bean> -->



</beans>
