<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
 	xmlns:security="http://www.springframework.org/schema/security"
 	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd 
	http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd">

<!-- BEGIN Security configuration ============================================================================ -->

<bean id="digestProcessingFilterEntryPoint"
	class="org.springframework.security.ui.digestauth.DigestProcessingFilterEntryPoint">
	<property name="realmName" value="${veriniceserver.realm}" />
	<property name="key" value="${veriniceserver.key}" />
	<property name="nonceValiditySeconds" value="${veriniceserver.nonceValiditySeconds}" />
</bean>

<!--
	Command to retrieve user configurations. We need to have this as a named bean to explicitly
    give security privileges to this instance.
     
    See the 'internalAuthenticationProvider' bean.
-->
<bean
	id="loadUserConfigurationCommand"
	class="sernet.gs.server.commands.LoadUserConfiguration">
</bean>
 
<bean id="uds" class="sernet.gs.server.security.DbUserDetailsService">
	<property name="loadUserConfigurationCommand" ref="loadUserConfigurationCommand"/>
	
	<property name="commandService" ref="commandService" />

	<property name="adminuser">
		<value>${admin.username}</value>
	</property>
	<property name="adminpass">
		<value>${admin.password}</value>
	</property>
</bean>

<!--
	The complex security configuration is only needed for the plain server that runs in a servlet container.
	
	The bundled server does not need this!  
 -->

<!-- service to allow application access to currently active roles, server realm etc.-->
<bean id="authService" class="sernet.gs.server.security.AuthenticationService">
	<property name="entryPoint" ref="digestProcessingFilterEntryPoint"/>

	<security:intercept-methods>
	<!-- must be logged in to access roles: -->
	<security:protect
		method="sernet.gs.server.security.AuthenticationService.getRoles" access="ROLE_USER,ROLE_ANONYMOUS" />
	<!-- must be logged in as admin to change passwords: -->
	<security:protect
		method="sernet.gs.server.security.AuthenticationService.hashPassword" access="ROLE_ADMIN" />
	</security:intercept-methods>
</bean>

<!-- the following beans enable http digest authentication and role based access -->

<security:authentication-manager alias="authenticationManager" />

<!-- 
	 Instead of digest auth, the authentication method can be switched, i.e. to basic auth over SSL with SHA hashes.
	 LDAP binding or LDAP password comparison are also possible, you'll have to change the authentication providers
	 and the hashing algorithm.
	 Please refer to the Spring framework security documentation for instructions on how to do this 
	 (http://static.springsource.org/spring-security/site/suggested.html).
 -->
<bean id="digestProcessingFilter"
	class="org.springframework.security.ui.digestauth.DigestProcessingFilter">
	<property name="userDetailsService" ref="uds" />
	<property name="authenticationEntryPoint"
			ref="digestProcessingFilterEntryPoint" />
	<property name="passwordAlreadyEncoded" value="true"/>
</bean>

<bean id="springSecurityFilterChain"
	class="org.springframework.security.util.FilterChainProxy">
	<security:filter-chain-map path-type="ant">
		<security:filter-chain pattern="/service/**"
			filters="httpSessionContextIntegrationFilter,digestProcessingFilter,exceptionTranslationFilter,filterSecurityInterceptor" />
	</security:filter-chain-map>
</bean>

<bean id="httpSessionContextIntegrationFilter"
	class="org.springframework.security.context.HttpSessionContextIntegrationFilter" />

<bean id="filterSecurityInterceptor"
	class="org.springframework.security.intercept.web.FilterSecurityInterceptor">
	
	<property name="authenticationManager"
		ref="authenticationManager" />
	
	<property name="accessDecisionManager"
		ref="accessDecisionManager" />
	
	<property name="objectDefinitionSource">
		<security:filter-invocation-definition-source>
			<security:intercept-url pattern="/service/**"
				access="ROLE_USER" />
		</security:filter-invocation-definition-source>
	</property>
</bean>

<bean id="accessDecisionManager"
	class="org.springframework.security.vote.AffirmativeBased">
	<property name="allowIfAllAbstainDecisions" value="false" />
	<property name="decisionVoters">
		<list>
			<bean class="org.springframework.security.vote.RoleVoter" />
		</list>
	</property>
</bean>

<bean id="exceptionTranslationFilter"
	class="org.springframework.security.ui.ExceptionTranslationFilter">
	<property name="authenticationEntryPoint"
	ref="digestProcessingFilterEntryPoint" />
</bean>

<security:authentication-provider  
	user-service-ref="uds">
</security:authentication-provider>

<bean id="internalAuthenticationProvider"
    class="sernet.gs.server.security.InternalAuthenticationProvider">
    <security:custom-authentication-provider />
    
    <property name="allowedInstances">
    	<set>
    		<ref bean="loadUserConfigurationCommand" />
    		<ref bean="penCommand" />
    	</set>
    </property>
</bean>

<aop:config>
	<aop:aspect
		ref="internalAuthenticationProvider" >
	
		<aop:pointcut
			id="commandServicePointcut" 
			expression="execution(* sernet.gs.ui.rcp.main.service.HibernateCommandService.executeCommand(..))" />
		
		<aop:around method="doInsertAuthentication" pointcut-ref="commandServicePointcut"/>
		
	</aop:aspect>
</aop:config>

<!-- END Security configuration ============================================================================ -->

</beans>
