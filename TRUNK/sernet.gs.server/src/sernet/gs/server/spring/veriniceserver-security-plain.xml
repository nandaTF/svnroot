<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd 
	http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-2.0.xsd">

	<!-- BEGIN Security configuration ============================================================================ -->

	<bean id="digestProcessingFilterEntryPoint" class="org.springframework.security.ui.digestauth.DigestProcessingFilterEntryPoint">
		<property name="realmName" value="${veriniceserver.realm}" />
		<property name="key" value="${veriniceserver.key}" />
		<property name="nonceValiditySeconds" value="${veriniceserver.nonceValiditySeconds}" />
	</bean>

	<!--
	Command to retrieve user configurations. We need to have this as a named bean to explicitly
    give security privileges to this instance.
     
    See the 'internalAuthenticationProvider' bean.
	-->
	
	<bean id="loadUserConfigurationCommand" class="sernet.gs.server.commands.LoadUserConfiguration">
	</bean>

	<bean id="uds" class="sernet.gs.server.security.DbUserDetailsService">
		<property name="loadUserConfigurationCommand" ref="loadUserConfigurationCommand" />

		<property name="commandService" ref="commandService" />

		<property name="adminuser">
			<value>${admin.username}</value>
		</property>
		<property name="adminpass">
			<value>${admin.password}</value>
		</property>
	</bean>

	<!--
	The complex security configuration is only needed for the plain server that runs in a servlet container.
	
	The bundled server does not need this!  
 -->

	<!-- service to allow application access to currently active roles, server realm etc.-->
	<bean id="authService" class="sernet.gs.server.security.AuthenticationService">
		<property name="entryPoint" ref="digestProcessingFilterEntryPoint" />

		<security:intercept-methods>
			<!-- must be logged in to access roles: -->
			<security:protect method="sernet.gs.server.security.AuthenticationService.getRoles" access="ROLE_USER" />
			<!-- must be logged in as admin to change passwords: -->
			<security:protect method="sernet.gs.server.security.AuthenticationService.hashPassword" access="ROLE_ADMIN" />
		</security:intercept-methods>
	</bean>

	<!-- the following beans enable http digest authentication and role based access -->

	<security:authentication-manager alias="authenticationManager" />

	<!-- 
	 Instead of digest auth, the authentication method can be switched, i.e. to basic auth over SSL with SHA hashes.
	 LDAP binding or LDAP password comparison are also possible, you'll have to change the authentication providers
	 and the hashing algorithm.
	 Please refer to the Spring framework security documentation for instructions on how to do this 
	 (http://static.springsource.org/spring-security/site/suggested.html).
 -->
	<bean id="digestProcessingFilter" class="org.springframework.security.ui.digestauth.DigestProcessingFilter">
		<property name="userDetailsService" ref="uds" />
		<property name="authenticationEntryPoint" ref="digestProcessingFilterEntryPoint" />
		<property name="passwordAlreadyEncoded" value="true" />
	</bean>

	<bean id="springSecurityFilterChain" class="org.springframework.security.util.FilterChainProxy">
		<security:filter-chain-map path-type="ant">
			<security:filter-chain pattern="/todo/**" filters="httpSessionContextIntegrationFilter,digestProcessingFilter,exceptionTranslationFilter,filterSecurityInterceptor" />

			<!-- editiert / filterchain fuer sync ordner muss deaktiviert sein -->
			 <security:filter-chain pattern="/sync/**" filters="httpSessionContextIntegrationFilter,digestProcessingFilter,exceptionTranslationFilter,filterSecurityInterceptor" /> 
			<!-- editiert -->
	
			<security:filter-chain pattern="/service/**" filters="httpSessionContextIntegrationFilter,digestProcessingFilter,exceptionTranslationFilter,filterSecurityInterceptor" />
		</security:filter-chain-map>
	</bean>

	<bean id="httpSessionContextIntegrationFilter" class="org.springframework.security.context.HttpSessionContextIntegrationFilter" />

	<bean id="filterSecurityInterceptor" class="org.springframework.security.intercept.web.FilterSecurityInterceptor">

		<property name="authenticationManager" ref="authenticationManager" />

		<property name="accessDecisionManager" ref="accessDecisionManager" />

		<property name="objectDefinitionSource">
			<security:filter-invocation-definition-source>
				<security:intercept-url pattern="/todo/**" access="ROLE_USER" />
				<security:intercept-url pattern="/service/**" access="ROLE_USER" />
				<security:intercept-url pattern="/sync/**" access="ROLE_USER" />
			</security:filter-invocation-definition-source>
		</property>
	</bean>

	<bean id="accessDecisionManager" class="org.springframework.security.vote.AffirmativeBased">
		<property name="allowIfAllAbstainDecisions" value="false" />
		<property name="decisionVoters">
			<list>
				<bean class="org.springframework.security.vote.RoleVoter" />
			</list>
		</property>
	</bean>

	<bean id="exceptionTranslationFilter" class="org.springframework.security.ui.ExceptionTranslationFilter">
		<property name="authenticationEntryPoint" ref="digestProcessingFilterEntryPoint" />
	</bean>

	<security:authentication-provider user-service-ref="uds">
	</security:authentication-provider>

	<!--
		Security configuration for pre-http authentication and internal commands. The security configuration above only deals with the authentication of the verinice client against the verinice server via http. However it misses two important issues: - for the login process we need to call a LoadUserConfiguration command At that time there is no valid authentication information and as such calling methods like AuthenticationService.getRole() fails. - internal commands like the mail notification job
		cannot authenticate via http As such those commands have no authentication information at all. For these cases we added another authentication mechanism. What we authenticate are <em>individual</em> ICommand instances which we trust. All trusted ICommand instances have to be created in the Spring configuration as a named bean and registered in the 'internalAuthenticationProvider' bean below. This Bean provides an AOP advice, ie. a method which is called for a pointcut. The advice intercepts
		the invocation of HibernateCommandService.executeCommand() and inspects the authentification situation and the first argument (an ICommand instance). If the instance is well-known the authentication is granted.
	-->

	<bean id="internalAuthenticationProvider" class="sernet.gs.server.security.InternalAuthenticationProvider">
		<security:custom-authentication-provider />

		<property name="allowedInstances">
			<set>
				<ref bean="loadUserConfigurationCommand" />
				<ref bean="pniCommand" />
			</set>
		</property>
	</bean>

	<aop:config>
		<aop:aspect ref="internalAuthenticationProvider">

			<aop:pointcut id="commandServicePointcut" expression="execution(* sernet.gs.ui.rcp.main.service.HibernateCommandService.executeCommand(..))" />

			<aop:around method="doInsertAuthentication" pointcut-ref="commandServicePointcut" />

		</aop:aspect>
	</aop:config>

	<!-- END Security configuration ============================================================================ -->

</beans>
