<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd 
	http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-2.0.xsd">
    
	<!-- BEGIN Security configuration ============================================================================ -->

	<!-- the following beans enable http authentication and role based access -->

    <!-- Default authentication manager -->
	<security:authentication-manager alias="authenticationManager" />
    
    <!-- The filter chain that all HTTP requests go through: -->
	<bean id="springSecurityFilterChain" class="org.springframework.security.util.FilterChainProxy">
		<security:filter-chain-map path-type="ant">
			<security:filter-chain pattern="/todo/**" filters="httpSessionContextIntegrationFilter,preAuthFilter,filterSecurityInterceptor" />
			 <security:filter-chain pattern="/sync/**" filters="httpSessionContextIntegrationFilter,preAuthFilter,filterSecurityInterceptor" /> 
			<security:filter-chain pattern="/service/**" filters="httpSessionContextIntegrationFilter,preAuthFilter,filterSecurityInterceptor" />
		</security:filter-chain-map>
	</bean>

    <!-- HTTP Header pre authentication: -->
    <!-- User has already been reliably authenticated by some external system. -->
    <!-- User name was set to a HTTP header. Configure header name in property principalRequestHeader. -->
    <!-- ATTENTION: verinice performs no authentication checks at all and it is extremely important -->
    <!-- that the external system is configured properly and protects all access to the application. -->
    
    <bean id="preAuthFilter" class="org.springframework.security.ui.preauth.header.RequestHeaderPreAuthenticatedProcessingFilter">
    	<security:custom-filter position="PRE_AUTH_FILTER" />
    	<!-- Name of HTTP-header containing the user name -->
    	<property name="principalRequestHeader" value="iv-user"/>
    	<property name="authenticationManager" ref="authenticationManager" />
  	</bean>
  	
  	<bean id="preauthAuthProvider" class="org.springframework.security.providers.preauth.PreAuthenticatedAuthenticationProvider">
    	<security:custom-authentication-provider />      
    	<property name="preAuthenticatedUserDetailsService">
      		<bean id="userDetailsServiceWrapper" class="org.springframework.security.userdetails.UserDetailsByNameServiceWrapper">
        		<property name="userDetailsService" ref="userDetailsService"/>
      		</bean>    
    	</property>
	</bean>
  	
  	<!-- userDetailsService is loading user data -->
    <bean id="userDetailsService" class="sernet.gs.server.security.DbUserDetailsService">
        <property name="entityDao" ref="entityDao" />
        <property name="adminuser">
            <value>${admin.username}</value>
        </property>
        <property name="adminpass">
            <value>${admin.password}</value>
        </property>
    </bean>
    
    <!-- END  HTTP Header pre authentication ================================================================== -->
    
    <!-- A programmatic way to access authenticated roles. Its methods are protected against unauthorized access: -->
    <bean id="authService" class="sernet.gs.server.security.BasicAuthenticationService">      
        <property name="guestUser" value="${ldap.guestuser}" />       
        <property  name="adminUsername" value="${admin.username}" />   
        <security:intercept-methods>
            <security:protect
                method="sernet.gs.server.security.BasicAuthenticationService.getRoles"
                access="ROLE_USER,ROLE_WEB" />
            <security:protect
                method="sernet.gs.server.security.BasicAuthenticationService.hashPassword"
                access="ROLE_ADMIN" />
        </security:intercept-methods>
    </bean>

	<bean id="httpSessionContextIntegrationFilter" class="org.springframework.security.context.HttpSessionContextIntegrationFilter" />

    <!-- Protect HTTP access to these paths: -->
	<bean id="filterSecurityInterceptor" class="org.springframework.security.intercept.web.FilterSecurityInterceptor">
		<property name="authenticationManager" ref="authenticationManager" />
		<property name="accessDecisionManager" ref="accessDecisionManager" />
		<property name="objectDefinitionSource">
			<security:filter-invocation-definition-source>
				<security:intercept-url pattern="/todo/**" access="ROLE_WEB" />
				<security:intercept-url pattern="/service/**" access="ROLE_USER" />
				<security:intercept-url pattern="/sync/**" access="ROLE_USER" />
			</security:filter-invocation-definition-source>
		</property>
	</bean>

	<bean id="accessDecisionManager" class="org.springframework.security.vote.AffirmativeBased">
		<property name="allowIfAllAbstainDecisions" value="false" />
		<property name="decisionVoters">
			<list>
				<bean class="org.springframework.security.vote.RoleVoter" />
			</list>
		</property>
	</bean>

	<!--
		Security configuration for pre-http authentication and internal commands. The security configuration above only deals with the authentication of the verinice client against the verinice server via http. However it misses two important issues: - for the login process we need to call a LoadUserConfiguration command At that time there is no valid authentication information and as such calling methods like AuthenticationService.getRole() fails. - internal commands like the mail notification job
		cannot authenticate via http As such those commands have no authentication information at all. For these cases we added another authentication mechanism. What we authenticate are <em>individual</em> ICommand instances which we trust. All trusted ICommand instances have to be created in the Spring configuration as a named bean and registered in the 'internalAuthenticationProvider' bean below. This Bean provides an AOP advice, ie. a method which is called for a pointcut. The advice intercepts
		the invocation of HibernateCommandService.executeCommand() and inspects the authentication situation and the first argument (an ICommand instance). If the instance is well-known the authentication is granted.
	-->

	<bean id="internalAuthenticationProvider" class="sernet.gs.server.security.InternalAuthenticationProvider">
		<security:custom-authentication-provider />
		<property name="allowedInstances">
			<set>
				<ref bean="pniCommand" />
			</set>
		</property>
	</bean>

	<aop:config>
		<aop:aspect ref="internalAuthenticationProvider">
			<aop:pointcut id="commandServicePointcut" expression="execution(* sernet.verinice.service.HibernateCommandService.executeCommand(..))" />
			<aop:around method="doInsertAuthentication" pointcut-ref="commandServicePointcut" />
		</aop:aspect>
	</aop:config>

	<!-- END Security configuration ============================================================================ -->
</beans>
